//! This crate aims to encapsulate the logic required for building `augeas`
//! from source (so that `augeas-sys` can use it).

use std::env;
use std::fs;
use std::path::{Path, PathBuf};

/// Information about the locations of files generated by `build()`.
///
/// After the jq sources have been compiled, the fields in this struct
/// represent where the various files ended up, and what sort of build was
/// done (ie, static or dynamic).
pub struct Artifacts {
    include_dir: PathBuf,
    lib_dir: PathBuf,
}

impl Artifacts {
    /// Prints cargo instructions for linking to the bundled `augeas` lib.
    pub fn print_cargo_metadata(&self) {
        println!("cargo:include={}", self.include_dir.display());
        println!("cargo:rustc-link-search=native={}", self.lib_dir.display());
        println!("cargo:rustc-link-lib=static={}", "augeas");
    }
    pub fn include_dir(&self) -> &Path {
        &self.include_dir
    }
    pub fn lib_dir(&self) -> &Path {
        &self.lib_dir
    }
}

/// Entry point for callers to run the build.
pub fn build() -> Result<Artifacts, String> {
    let out_dir = env::var_os("OUT_DIR")
        .map(PathBuf::from)
        .expect("OUT_DIR not set");

    let augeas_dir = Path::new(env!("CARGO_MANIFEST_DIR")).join("augeas");

    autotools::Config::new(&augeas_dir)
        .reconf("-iv")
        .out_dir(&out_dir)
        .enable_static()
        .disable_shared()
        .try_build()?;

    Ok(Artifacts {
        lib_dir: out_dir.join("lib"),
        include_dir: out_dir.join("include"),
    })
}

/// Recursive file copy
fn cp_r(src: &Path, dst: &Path) {
    for f in fs::read_dir(src).unwrap() {
        let f = f.unwrap();
        let path = f.path();
        let name = path.file_name().unwrap();
        let dst = dst.join(name);
        if f.file_type().unwrap().is_dir() {
            fs::create_dir_all(&dst).unwrap();
            cp_r(&path, &dst);
        } else {
            let _ = fs::remove_file(&dst);
            fs::copy(&path, &dst).unwrap();
        }
    }
}

/// Cleanup old sources (left from a previous build attempt) then copy from
/// the git submodule into the location where the build will happen.
fn prepare_sources(src: &Path, dst: &Path) {
    if dst.exists() {
        fs::remove_dir_all(dst).unwrap();
    }
    fs::create_dir_all(dst).unwrap();
    cp_r(src, dst);
}
